<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="format-detection" content="telephone=no" />
    <meta name="MobileOptimized" content="176" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="theme-color" content="#000000" />

    <link rel="stylesheet" href="./global.css" />
    <link rel="stylesheet" href="./flip.css" />
  </head>
  <body>
    <div class="flip">
      <!-- Background Music -->
      <audio id="bgMusic" loop>
        <source src="./public/music.mp3" type="audio/mpeg" />
      </audio>

      <img class="background-image" alt="" src="./public/cpbg.png" />

      <section class="menu">
        <div class="buttons">
          <img
            class="back-button-icon"
            alt=""
            src="./public/back-button@2x.png"
            onclick="history.back()"
          />
        </div>
        <div class="title-wrapper">
          <div class="title">COIN FLIP</div>
        </div>
        <div class="buttons">
          <img
            class="settings-button-icon"
            alt=""
            src="./public/settings-button@2x.png"
            onclick="document.getElementById('settings-panel').style.display = 'block'"
          />
        </div>
      </section>

      <section class="game-content">
        <div class="top-bar">
          <div class="timer">Timer: <span id="countdown">90</span> Sec</div>
          <div class="balance"><span id="userBalance">100</span></div>
        </div>

        <div class="history-row">
          <div class="history-coins" id="historyCoins"></div>
        </div>

        <div class="chart-container">
          <div class="greek-pattern top"></div>
          <canvas id="flipChart"></canvas>
          <div class="greek-pattern bottom"></div>
        </div>

        <div class="coin-container">
          <!-- Result Indicator -->
          <div class="result-indicator" id="resultIndicator"></div>

          <div class="main-coin" id="mainCoin">
            <div class="greek-pattern circle"></div>
            <img src="./public/coin@2x.png" alt="Coin" class="coin-face" />
          </div>

          <div class="selection-container">
            <div class="side-option heads" onclick="game.selectSide('heads')">
              <img src="./public/coin@2x.png" alt="Heads" class="side-icon" />
              <span class="side-label">HEADS</span>
            </div>
            <div class="side-option tails" onclick="game.selectSide('tails')">
              <img src="./public/tail.png" alt="Tails" class="side-icon" />
              <span class="side-label">TAILS</span>
            </div>
          </div>

          <form
            onsubmit="event.preventDefault(); document.activeElement.blur();"
            class="bet-container"
          >
            <div class="greek-pattern left"></div>
            <input
              type="number"
              id="betAmount"
              class="bet-input"
              placeholder="ENTER BET AMOUNT"
              inputmode="numeric"
              pattern="[0-9]*"
              enterkeyhint="done"
            />
            <div class="bet-controls">
              <button type="button" onclick="adjustBet('up')" class="bet-arrow">
                ▲
              </button>
              <button
                type="button"
                onclick="adjustBet('down')"
                class="bet-arrow"
              >
                ▼
              </button>
            </div>
            <div class="greek-pattern right"></div>
          </form>

          <button class="flip-button" onclick="game.flipCoin()">
            <span class="flip-text">FLIP COIN</span>
          </button>
        </div>
      </section>

      <!-- Footer navigation -->
      <footer class="lower-menu">
        <a href="./referral.html" class="menu-item">
          <img
            class="menu-icon"
            src="./public/shop-icon@2x.png"
            alt="Referral"
          />
          <span class="menu-text">Referral</span>
        </a>
        <a href="./quest.html" class="menu-item">
          <img
            class="menu-icon"
            src="./public/quest-icom@2x.png"
            alt="Quests"
          />
          <span class="menu-text">Quests</span>
        </a>
        <a href="./leader-board.html" class="menu-item">
          <img
            class="menu-icon"
            src="./public/trophy-icon@2x.png"
            alt="Leaderboard"
          />
          <span class="menu-text">Leaderboard</span>
        </a>
      </footer>

      <!-- Settings Panel -->
      <div id="settings-panel" class="settings-panel" style="display: none">
        <div class="settings-content">
          <h3>Settings</h3>
          <div class="volume-control">
            <label for="volume">Music Volume:</label>
            <input
              type="range"
              id="volume"
              min="0"
              max="1"
              step="0.1"
              value="0.5"
              onchange="document.getElementById('bgMusic').volume = this.value"
            />
          </div>
          <button
            onclick="document.getElementById('settings-panel').style.display = 'none'"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
      const LABELS = Array(100).fill(0);
      const GAME_CONFIG = {
        INITIAL_BALANCE: 100,
        TIMER_DURATION: 90,
        MAX_HISTORY_COINS: 7,
        MARKET_THRESHOLDS: {
          BULL: 0.7,
          BEAR: 0.3,
        },
        KELLY_CRITERION: {
          BULL: 0.4,
          BEAR: 0.06,
          CHOPPY: 0.2,
        },
      };

      class EventEmitter {
        constructor() {
          this.events = {};
        }

        on(event, callback) {
          if (!this.events[event]) {
            this.events[event] = [];
          }
          this.events[event].push(callback);
        }

        emit(event, data) {
          if (this.events[event]) {
            this.events[event].forEach((callback) => callback(data));
          }
        }
      }

      class GameState {
        constructor() {
          this.balance = GAME_CONFIG.INITIAL_BALANCE;
          this.selectedSide = "heads";
          this.flipHistory = [];
          this.balanceHistory = [GAME_CONFIG.INITIAL_BALANCE];
          this.betsHistory = [];
          this.timer = GAME_CONFIG.TIMER_DURATION;
        }

        updateBalance(amount) {
          this.balance += amount;
          this.balanceHistory.push(this.balance);
          if (this.balanceHistory.length > 10) {
            this.balanceHistory.shift();
          }
        }

        addFlipResult(result) {
          this.flipHistory.push(result);
        }

        addBet(bet) {
          this.betsHistory.push(bet);
        }

        reset() {
          this.balance = GAME_CONFIG.INITIAL_BALANCE;
          this.selectedSide = "heads";
          this.flipHistory = [];
          this.balanceHistory = [GAME_CONFIG.INITIAL_BALANCE];
          this.betsHistory = [];
          this.timer = GAME_CONFIG.TIMER_DURATION;
        }
      }

      class MarketAnalyzer {
        static determineState(balanceHistory) {
          if (balanceHistory.length < 3) return "choppy";

          const recentChanges = [];
          for (let i = 1; i < balanceHistory.length; i++) {
            recentChanges.push(balanceHistory[i] - balanceHistory[i - 1]);
          }

          const positiveRatio =
            recentChanges.filter((change) => change > 0).length /
            recentChanges.length;

          if (positiveRatio >= GAME_CONFIG.MARKET_THRESHOLDS.BULL)
            return "bull";
          if (positiveRatio <= GAME_CONFIG.MARKET_THRESHOLDS.BEAR)
            return "bear";
          return "choppy";
        }

        static calculateOptimalBet(currentBalance, marketState) {
          return (
            currentBalance *
            GAME_CONFIG.KELLY_CRITERION[marketState.toUpperCase()]
          );
        }
      }

      class GameUI {
        constructor(eventEmitter) {
          this.eventEmitter = eventEmitter;
          this.initializeElements();
          this.bindEvents();
        }

        initializeElements() {
          this.elements = {
            balance: document.getElementById("userBalance"),
            betInput: document.getElementById("betAmount"),
            historyCoins: document.getElementById("historyCoins"),
            countdown: document.getElementById("countdown"),
            mainCoin: document.querySelector(".main-coin"),
            resultIndicator: document.getElementById("resultIndicator"),
            chart: document.getElementById("flipChart"),
          };
        }

        bindEvents() {
          this.elements.betInput.addEventListener("keyup", (event) => {
            if (event.key === "Enter") event.target.blur();
          });

          this.elements.betInput.addEventListener("blur", (event) => {
            const currentBet = parseInt(event.target.value) || 0;
            const balance = parseInt(this.elements.balance.textContent);
            event.target.value = Math.min(currentBet, balance);
          });
        }

        updateBalance(balance) {
          this.elements.balance.textContent = balance.toString();
        }

        updateTimer(time) {
          this.elements.countdown.textContent = time.toString();
        }

        showResultIndicator(amount) {
          const indicator = this.elements.resultIndicator;
          indicator.textContent = `${amount > 0 ? "+" : ""}${amount}`;
          indicator.className = `result-indicator ${
            amount > 0 ? "win" : "lose"
          }`;

          indicator.style.animation = "none";
          indicator.offsetHeight; // Trigger reflow
          indicator.style.animation = null;
          indicator.classList.add("animate");

          setTimeout(() => {
            indicator.classList.remove("animate");
          }, 1500);
        }

        updateHistory(result) {
          const newCoin = document.createElement("img");
          newCoin.src = `./public/${
            result === "heads" ? "coin@2x" : "tail"
          }.png`;
          newCoin.className = "history-coin";

          this.elements.historyCoins.insertBefore(
            newCoin,
            this.elements.historyCoins.firstChild
          );

          while (
            this.elements.historyCoins.children.length >
            GAME_CONFIG.MAX_HISTORY_COINS
          ) {
            this.elements.historyCoins.removeChild(
              this.elements.historyCoins.lastChild
            );
          }
        }
      }

      class ChartManager {
        constructor(canvasId) {
          this.ctx = document.getElementById(canvasId).getContext("2d");
          this.chart = null;
          this.initializeChart();
        }

        initializeChart() {
          const initialData = {
            labels: LABELS,
            datasets: [
              {
                data: [GAME_CONFIG.INITIAL_BALANCE],
                borderColor: "rgb(255, 204, 0)",
                backgroundColor: "rgb(255, 204, 0)",
                stepped: "middle",
                pointRadius: 0,
                tension: 0,
                segment: { borderJoinStyle: "round" },
                borderWidth: 1.5,
              },
            ],
          };

          const [max, min] = this.generateAxisBounds(
            initialData.datasets[0].data
          );

          this.chart = new Chart(this.ctx, {
            type: "line",
            data: initialData,
            options: {
              responsive: true,
              maintainAspectRatio: true,
              scales: {
                y: {
                  min,
                  max,
                  ticks: {
                    count: 4,
                    color: "#fff",
                    font: { size: 10, family: "GemFont One" },
                  },
                  grid: { display: false },
                  beginAtZero: false,
                  border: { color: "#fff", width: 0.5 },
                },
                x: {
                  display: false,
                  position: "bottom",
                  grid: { display: false },
                },
              },
              plugins: {
                title: { display: false },
                subtitle: { display: false },
                legend: { display: false },
                tooltip: { enabled: false },
              },
              animation: { duration: 0 },
            },
          });
        }

        updateChart(newBalance) {
          const balanceHistory = this.chart.data.datasets[0].data;
          balanceHistory.push(newBalance);
          this.chart.update();

          if (this.chart.data.labels.length < balanceHistory.length) {
            this.chart.data.labels.push(0);
          }

          const [max, min] = this.generateAxisBounds(balanceHistory);
          this.chart.options.scales.y.min = min;
          this.chart.options.scales.y.max = max;
        }

        breathe() {
          const balanceHistory = this.chart.data.datasets[0].data;
          const lastBalance = balanceHistory[balanceHistory.length - 1];
          this.updateChart(lastBalance);
        }

        generateAxisBounds(values) {
          const minValue = Math.min(...values);
          const maxValue = Math.max(...values);
          const range = maxValue - minValue;
          const padding = Math.max(range * 0.1, 20);

          let min = Math.floor((minValue - padding) / 20) * 20;
          let max = Math.ceil((maxValue + padding) / 20) * 20;

          if (min === max) {
            const baseValue = values[0];
            const adjustment = Math.max(Math.abs(baseValue) * 0.2, 40);
            min = Math.floor((baseValue - adjustment) / 20) * 20;
            max = Math.ceil((baseValue + adjustment) / 20) * 20;
          }

          return [max, min];
        }
      }

      class CoinFlipGame {
        constructor() {
          this.eventEmitter = new EventEmitter();
          this.state = new GameState();
          this.ui = new GameUI(this.eventEmitter);
          this.chartManager = new ChartManager("flipChart");
          this.timerInterval = null;

          this.initializeGame();
          this.setupEventListeners();
        }

        initializeGame() {
          this.state.reset();
          this.ui.updateBalance(this.state.balance);
          this.startTimer();
        }

        setupEventListeners() {
          this.eventEmitter.on("flip", () => this.flipCoin());
          this.eventEmitter.on("selectSide", (side) => this.selectSide(side));
          this.eventEmitter.on("adjustBet", (direction) =>
            this.adjustBet(direction)
          );
        }

        startTimer() {
          clearInterval(this.timerInterval);
          this.state.timer = GAME_CONFIG.TIMER_DURATION;
          this.ui.updateTimer(this.state.timer);

          this.timerInterval = setInterval(() => {
            this.state.timer--;
            this.chartManager.breathe();
            this.chartManager.chart.data.datasets[0].data;

            if (this.state.timer <= 0) {
              this.endGame();
            }
            this.ui.updateTimer(this.state.timer);
          }, 1000);
        }

        endGame() {
          clearInterval(this.timerInterval);
          const gameData = {
            balance: this.state.balance,
            history: this.state.flipHistory,
            balanceHistory: this.state.balanceHistory,
            bets: this.state.betsHistory,
          };
          localStorage.setItem("gameData", JSON.stringify(gameData));
          window.location.href = "./stats.html";
        }

        flipCoin() {
          const betAmount = parseInt(this.ui.elements.betInput.value);

          if (!this.validateBet(betAmount)) return;

          const marketState = MarketAnalyzer.determineState(
            this.state.balanceHistory
          );
          const optimalBet = MarketAnalyzer.calculateOptimalBet(
            this.state.balance,
            marketState
          );

          this.state.addBet({
            amount: betAmount,
            optimalBet,
            balance: this.state.balance,
            marketState,
          });

          this.animateFlip(betAmount, marketState);
        }

        validateBet(betAmount) {
          if (!betAmount || betAmount <= 0 || betAmount > this.state.balance) {
            this.showError(
              betAmount > this.state.balance
                ? "Insufficient Balance"
                : "Invalid Bet"
            );
            return false;
          }
          return true;
        }

        animateFlip(betAmount, marketState) {
          this.ui.elements.mainCoin.classList.add("flipping");

          setTimeout(() => {
            const result = Math.random() < 0.5 ? "heads" : "tails";
            const won = result === this.state.selectedSide;
            const balanceChange = won ? betAmount : -betAmount;

            this.state.updateBalance(balanceChange);
            this.ui.updateBalance(this.state.balance);
            this.ui.showResultIndicator(balanceChange);

            this.state.addFlipResult({
              side: this.state.selectedSide,
              result,
              bet: betAmount,
              won,
              balanceChange,
              marketState,
            });

            this.ui.updateHistory(result);
            this.chartManager.updateChart(this.state.balance);

            this.ui.elements.mainCoin.classList.remove("flipping");
            this.ui.elements.mainCoin.querySelector("img").src = `./public/${
              result === "heads" ? "coin@2x" : "tail"
            }.png`;
          }, 1000);
        }

        showError(message) {
          if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.showPopup({
              title: message,
              message:
                message === "Invalid Bet"
                  ? "Please enter a valid bet amount"
                  : "Not enough balance for this bet",
              buttons: [{ type: "ok" }],
            });
          } else {
            alert(message);
          }
        }

        selectSide(side) {
          this.state.selectedSide = side;
          document
            .querySelector(".heads")
            .classList.toggle("active", side === "heads");
          document
            .querySelector(".tails")
            .classList.toggle("active", side === "tails");
          this.ui.elements.mainCoin.querySelector("img").src = `./public/${
            side === "heads" ? "coin@2x" : "tail"
          }.png`;
        }

        adjustBet(direction) {
          const currentBet = parseInt(this.ui.elements.betInput.value) || 0;
          this.ui.elements.betInput.value =
            direction === "up"
              ? Math.min(currentBet + 100, this.state.balance)
              : Math.max(currentBet - 100, 0);
        }
      }

      // Instantiate game
      const game = new CoinFlipGame();

      document.addEventListener("DOMContentLoaded", () => {
        if (window.Telegram && window.Telegram.WebApp) {
          const webapp = window.Telegram.WebApp;
          webapp.ready();
          webapp.expand();
        }

        const bgMusic = document.getElementById("bgMusic");
        if (bgMusic) {
          bgMusic.volume = 0.5;
          bgMusic.play().catch(console.error);
        }
      });
    </script>
  </body>
</html>
